import {ECSignature, PlainDexOrder, PlainUnsignedOrder} from '@nexex/types';
import {ethers, Signer, utils} from 'ethers';
import {Provider} from 'ethers/providers';
/* tslint:disable no-import-side-effect */
import 'reflect-metadata';
import {PortalEntry} from './constants';
import {Exchange} from './contracts/Exchange';
import {Portal} from './contracts/Portal';
import {TokenHelper} from './contracts/TokenHelper';
import {TokenRegistry} from './contracts/TokenRegistry';
import {DexConfig} from './types';
import {orderUtil} from './utils';
import {assert} from './utils/assert';

const {arrayify, hashMessage, randomBytes, splitSignature} = utils;
/* tslint:enable */
export class Dex {
    static async create(config: DexConfig): Promise<Dex> {
        const dex = new Dex(config);
        await dex.init();
        return dex;
    }

    eth: Provider;
    signer: Signer;
    config: DexConfig;
    portal: Portal;
    exchange: Exchange;
    token: TokenHelper;
    tokenRegistry: TokenRegistry;

    protected constructor(config: DexConfig) {
        this.config = config;
        const {portalAddr, provider, network} = config;
        if (!provider) {
            this.eth = ethers.getDefaultProvider(network);
        } else if (typeof provider === 'string') {
            this.eth = new ethers.providers.JsonRpcProvider(provider);
        } else {
            this.eth = provider;
        }
        this.portal = new Portal(this.eth, config.network, portalAddr);
    }

    /**
     * Generates a pseudo-random 256-bit salt.
     * The salt can be included in a 0x order, ensuring that the order generates a unique orderHash
     * and will not collide with other outstanding orders that are identical in all other parameters.
     * @return  A pseudo-random 256-bit number that can be used as a salt.
     */
    public static generatePseudoRandomSalt(): string {
        return ethers.utils.bigNumberify(randomBytes(32)).toString();
    }

    protected async init(): Promise<void> {
        const [exchangeAddr, registryAddr] = [
            await this.portal.portalEntries(PortalEntry.Exchange),
            // await this.portal.portalEntries(PortalEntry.TransferGateway),
            await this.portal.portalEntries(PortalEntry.TokenRegistry)
        ];
        this.exchange = new Exchange(this.eth, this.config.network, exchangeAddr);
        this.tokenRegistry = new TokenRegistry(this.eth, this.config.network, registryAddr);
        // this.transferProxy = new TokenTransferProxy(this.eth, gatewayAddr);
        const [wethAddress, gatewayAddr] = [
            await this.tokenRegistry.getTokenBySymbol('WETH'),
            await this.exchange.tokenTransferProxy()
        ];
        this.token = new TokenHelper(this.eth, this.config.network, gatewayAddr, wethAddress.addr);
    }

    public async signOrder(signer: Signer, order: PlainUnsignedOrder): Promise<PlainDexOrder> {
        const orderHash = orderUtil.getOrderHashHex(order);
        const ecSignature = await this.signOrderHash(signer, orderHash);
        return {...order, ecSignature};
    }

    /**
     * Signs an orderHash and returns it's elliptic curve signature.
     * This method currently supports TestRPC, Geth and Parity above and below V1.6.6
     * @param   orderHash       Hex encoded orderHash to sign.
     * @param   signerAddress   The hex encoded Ethereum address you wish to sign it with. This address
     *          must be available via the Web3.Provider supplied to 0x.js.
     * @param   shouldAddPersonalMessagePrefix  Some signers add the personal message prefix `\x19Ethereum Signed Message`
     *          themselves (e.g Parity Signer, Ledger, TestRPC) and others expect it to already be done by the client
     *          (e.g Metamask). Depending on which signer this request is going to, decide on whether to add the prefix
     *          before sending the request.
     * @return  An object containing the Elliptic curve signature parameters generated by signing the orderHash.
     */
    public async signOrderHash(
        signer: Signer,
        orderHash: string,
        shouldAddPersonalMessagePrefix: boolean = false
    ): Promise<ECSignature> {
        assert.isHexString('orderHash', orderHash);
        let msgHashBuff = arrayify(orderHash);
        if (shouldAddPersonalMessagePrefix) {
            msgHashBuff = arrayify(hashMessage(msgHashBuff));
        }

        const signature = await signer.signMessage(msgHashBuff);
        const {r, s, v} = splitSignature(signature);

        return {r, s, v};
    }
}
